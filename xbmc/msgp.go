package xbmc

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// MarshalMsg implements msgp.Marshaler
func (z ActivePlayers) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for za0001 := range z {
		// map header, size 2
		// string "ID"
		o = append(o, 0x82, 0xa2, 0x49, 0x44)
		o = msgp.AppendInt(o, z[za0001].ID)
		// string "Type"
		o = append(o, 0xa4, 0x54, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, z[za0001].Type)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ActivePlayers) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(ActivePlayers, zb0002)
	}
	for zb0001 := range *z {
		var field []byte
		_ = field
		var zb0003 uint32
		zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		for zb0003 > 0 {
			zb0003--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			switch msgp.UnsafeString(field) {
			case "ID":
				(*z)[zb0001].ID, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001, "ID")
					return
				}
			case "Type":
				(*z)[zb0001].Type, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001, "Type")
					return
				}
			default:
				bts, err = msgp.Skip(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ActivePlayers) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0004 := range z {
		s += 1 + 3 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z[zb0004].Type)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AdvancedSettings) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "LogLevel"
	o = append(o, 0x82, 0xa8, 0x4c, 0x6f, 0x67, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.LogLevel)
	// string "Cache"
	o = append(o, 0xa5, 0x43, 0x61, 0x63, 0x68, 0x65)
	// map header, size 4
	// string "MemorySizeLegacy"
	o = append(o, 0x84, 0xb0, 0x4d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x53, 0x69, 0x7a, 0x65, 0x4c, 0x65, 0x67, 0x61, 0x63, 0x79)
	o = msgp.AppendInt(o, z.Cache.MemorySizeLegacy)
	// string "MemorySize"
	o = append(o, 0xaa, 0x4d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.Cache.MemorySize)
	// string "BufferMode"
	o = append(o, 0xaa, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x65)
	o = msgp.AppendInt(o, z.Cache.BufferMode)
	// string "ReadFactor"
	o = append(o, 0xaa, 0x52, 0x65, 0x61, 0x64, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72)
	o = msgp.AppendInt(o, z.Cache.ReadFactor)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AdvancedSettings) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "LogLevel":
			z.LogLevel, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LogLevel")
				return
			}
		case "Cache":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Cache")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cache")
					return
				}
				switch msgp.UnsafeString(field) {
				case "MemorySizeLegacy":
					z.Cache.MemorySizeLegacy, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Cache", "MemorySizeLegacy")
						return
					}
				case "MemorySize":
					z.Cache.MemorySize, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Cache", "MemorySize")
						return
					}
				case "BufferMode":
					z.Cache.BufferMode, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Cache", "BufferMode")
						return
					}
				case "ReadFactor":
					z.Cache.ReadFactor, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Cache", "ReadFactor")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Cache")
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AdvancedSettings) Msgsize() (s int) {
	s = 1 + 9 + msgp.IntSize + 6 + 1 + 17 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ContextMenuItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Label"
	o = append(o, 0x82, 0xa5, 0x4c, 0x61, 0x62, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Label)
	// string "Action"
	o = append(o, 0xa6, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Action)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ContextMenuItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Label":
			z.Label, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Label")
				return
			}
		case "Action":
			z.Action, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Action")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ContextMenuItem) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Label) + 7 + msgp.StringPrefixSize + len(z.Action)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FileSources) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Sources"
	o = append(o, 0x81, 0xa7, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Sources)))
	for za0001 := range z.Sources {
		// map header, size 2
		// string "FilePath"
		o = append(o, 0x82, 0xa8, 0x46, 0x69, 0x6c, 0x65, 0x50, 0x61, 0x74, 0x68)
		o = msgp.AppendString(o, z.Sources[za0001].FilePath)
		// string "Label"
		o = append(o, 0xa5, 0x4c, 0x61, 0x62, 0x65, 0x6c)
		o = msgp.AppendString(o, z.Sources[za0001].Label)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FileSources) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Sources":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sources")
				return
			}
			if cap(z.Sources) >= int(zb0002) {
				z.Sources = (z.Sources)[:zb0002]
			} else {
				z.Sources = make([]struct {
					FilePath string `json:"file"`
					Label    string `json:"label"`
				}, zb0002)
			}
			for za0001 := range z.Sources {
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sources", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Sources", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "FilePath":
						z.Sources[za0001].FilePath, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Sources", za0001, "FilePath")
							return
						}
					case "Label":
						z.Sources[za0001].Label, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Sources", za0001, "Label")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Sources", za0001)
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FileSources) Msgsize() (s int) {
	s = 1 + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Sources {
		s += 1 + 9 + msgp.StringPrefixSize + len(z.Sources[za0001].FilePath) + 6 + msgp.StringPrefixSize + len(z.Sources[za0001].Label)
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z GUIIconOverlay) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GUIIconOverlay) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = GUIIconOverlay(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z GUIIconOverlay) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z KodiTime) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Time"
	o = append(o, 0x81, 0xa4, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.Time)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *KodiTime) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Time":
			z.Time, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Time")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z KodiTime) Msgsize() (s int) {
	s = 1 + 5 + msgp.TimeSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ListItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 13
	// string "Label"
	o = append(o, 0x8d, 0xa5, 0x4c, 0x61, 0x62, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Label)
	// string "Label2"
	o = append(o, 0xa6, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x32)
	o = msgp.AppendString(o, z.Label2)
	// string "Icon"
	o = append(o, 0xa4, 0x49, 0x63, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Icon)
	// string "Thumbnail"
	o = append(o, 0xa9, 0x54, 0x68, 0x75, 0x6d, 0x62, 0x6e, 0x61, 0x69, 0x6c)
	o = msgp.AppendString(o, z.Thumbnail)
	// string "IsPlayable"
	o = append(o, 0xaa, 0x49, 0x73, 0x50, 0x6c, 0x61, 0x79, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.IsPlayable)
	// string "Path"
	o = append(o, 0xa4, 0x50, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.Path)
	// string "Info"
	o = append(o, 0xa4, 0x49, 0x6e, 0x66, 0x6f)
	if z.Info == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Info.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Info")
			return
		}
	}
	// string "Properties"
	o = append(o, 0xaa, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73)
	if z.Properties == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Properties.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Properties")
			return
		}
	}
	// string "Art"
	o = append(o, 0xa3, 0x41, 0x72, 0x74)
	if z.Art == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Art.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Art")
			return
		}
	}
	// string "StreamInfo"
	o = append(o, 0xaa, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
	if z.StreamInfo == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.StreamInfo.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "StreamInfo")
			return
		}
	}
	// string "ContextMenu"
	o = append(o, 0xab, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x4d, 0x65, 0x6e, 0x75)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ContextMenu)))
	for za0001 := range z.ContextMenu {
		o = msgp.AppendArrayHeader(o, uint32(len(z.ContextMenu[za0001])))
		for za0002 := range z.ContextMenu[za0001] {
			o = msgp.AppendString(o, z.ContextMenu[za0001][za0002])
		}
	}
	// string "CastMembers"
	o = append(o, 0xab, 0x43, 0x61, 0x73, 0x74, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CastMembers)))
	for za0003 := range z.CastMembers {
		o, err = z.CastMembers[za0003].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "CastMembers", za0003)
			return
		}
	}
	// string "TraktAuth"
	o = append(o, 0xa9, 0x54, 0x72, 0x61, 0x6b, 0x74, 0x41, 0x75, 0x74, 0x68)
	o = msgp.AppendBool(o, z.TraktAuth)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ListItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Label":
			z.Label, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Label")
				return
			}
		case "Label2":
			z.Label2, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Label2")
				return
			}
		case "Icon":
			z.Icon, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Icon")
				return
			}
		case "Thumbnail":
			z.Thumbnail, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Thumbnail")
				return
			}
		case "IsPlayable":
			z.IsPlayable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsPlayable")
				return
			}
		case "Path":
			z.Path, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "Info":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Info = nil
			} else {
				if z.Info == nil {
					z.Info = new(ListItemInfo)
				}
				bts, err = z.Info.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Info")
					return
				}
			}
		case "Properties":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Properties = nil
			} else {
				if z.Properties == nil {
					z.Properties = new(ListItemProperties)
				}
				bts, err = z.Properties.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Properties")
					return
				}
			}
		case "Art":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Art = nil
			} else {
				if z.Art == nil {
					z.Art = new(ListItemArt)
				}
				bts, err = z.Art.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Art")
					return
				}
			}
		case "StreamInfo":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StreamInfo = nil
			} else {
				if z.StreamInfo == nil {
					z.StreamInfo = new(StreamInfo)
				}
				bts, err = z.StreamInfo.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "StreamInfo")
					return
				}
			}
		case "ContextMenu":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ContextMenu")
				return
			}
			if cap(z.ContextMenu) >= int(zb0002) {
				z.ContextMenu = (z.ContextMenu)[:zb0002]
			} else {
				z.ContextMenu = make([][]string, zb0002)
			}
			for za0001 := range z.ContextMenu {
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ContextMenu", za0001)
					return
				}
				if cap(z.ContextMenu[za0001]) >= int(zb0003) {
					z.ContextMenu[za0001] = (z.ContextMenu[za0001])[:zb0003]
				} else {
					z.ContextMenu[za0001] = make([]string, zb0003)
				}
				for za0002 := range z.ContextMenu[za0001] {
					z.ContextMenu[za0001][za0002], bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ContextMenu", za0001, za0002)
						return
					}
				}
			}
		case "CastMembers":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CastMembers")
				return
			}
			if cap(z.CastMembers) >= int(zb0004) {
				z.CastMembers = (z.CastMembers)[:zb0004]
			} else {
				z.CastMembers = make([]ListItemCastMember, zb0004)
			}
			for za0003 := range z.CastMembers {
				bts, err = z.CastMembers[za0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CastMembers", za0003)
					return
				}
			}
		case "TraktAuth":
			z.TraktAuth, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TraktAuth")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ListItem) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Label) + 7 + msgp.StringPrefixSize + len(z.Label2) + 5 + msgp.StringPrefixSize + len(z.Icon) + 10 + msgp.StringPrefixSize + len(z.Thumbnail) + 11 + msgp.BoolSize + 5 + msgp.StringPrefixSize + len(z.Path) + 5
	if z.Info == nil {
		s += msgp.NilSize
	} else {
		s += z.Info.Msgsize()
	}
	s += 11
	if z.Properties == nil {
		s += msgp.NilSize
	} else {
		s += z.Properties.Msgsize()
	}
	s += 4
	if z.Art == nil {
		s += msgp.NilSize
	} else {
		s += z.Art.Msgsize()
	}
	s += 11
	if z.StreamInfo == nil {
		s += msgp.NilSize
	} else {
		s += z.StreamInfo.Msgsize()
	}
	s += 12 + msgp.ArrayHeaderSize
	for za0001 := range z.ContextMenu {
		s += msgp.ArrayHeaderSize
		for za0002 := range z.ContextMenu[za0001] {
			s += msgp.StringPrefixSize + len(z.ContextMenu[za0001][za0002])
		}
	}
	s += 12 + msgp.ArrayHeaderSize
	for za0003 := range z.CastMembers {
		s += z.CastMembers[za0003].Msgsize()
	}
	s += 10 + msgp.BoolSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ListItemArt) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "Thumbnail"
	o = append(o, 0x8a, 0xa9, 0x54, 0x68, 0x75, 0x6d, 0x62, 0x6e, 0x61, 0x69, 0x6c)
	o = msgp.AppendString(o, z.Thumbnail)
	// string "Poster"
	o = append(o, 0xa6, 0x50, 0x6f, 0x73, 0x74, 0x65, 0x72)
	o = msgp.AppendString(o, z.Poster)
	// string "TvShowPoster"
	o = append(o, 0xac, 0x54, 0x76, 0x53, 0x68, 0x6f, 0x77, 0x50, 0x6f, 0x73, 0x74, 0x65, 0x72)
	o = msgp.AppendString(o, z.TvShowPoster)
	// string "Banner"
	o = append(o, 0xa6, 0x42, 0x61, 0x6e, 0x6e, 0x65, 0x72)
	o = msgp.AppendString(o, z.Banner)
	// string "FanArt"
	o = append(o, 0xa6, 0x46, 0x61, 0x6e, 0x41, 0x72, 0x74)
	o = msgp.AppendString(o, z.FanArt)
	// string "FanArts"
	o = append(o, 0xa7, 0x46, 0x61, 0x6e, 0x41, 0x72, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.FanArts)))
	for za0001 := range z.FanArts {
		o = msgp.AppendString(o, z.FanArts[za0001])
	}
	// string "ClearArt"
	o = append(o, 0xa8, 0x43, 0x6c, 0x65, 0x61, 0x72, 0x41, 0x72, 0x74)
	o = msgp.AppendString(o, z.ClearArt)
	// string "ClearLogo"
	o = append(o, 0xa9, 0x43, 0x6c, 0x65, 0x61, 0x72, 0x4c, 0x6f, 0x67, 0x6f)
	o = msgp.AppendString(o, z.ClearLogo)
	// string "Landscape"
	o = append(o, 0xa9, 0x4c, 0x61, 0x6e, 0x64, 0x73, 0x63, 0x61, 0x70, 0x65)
	o = msgp.AppendString(o, z.Landscape)
	// string "Icon"
	o = append(o, 0xa4, 0x49, 0x63, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Icon)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ListItemArt) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Thumbnail":
			z.Thumbnail, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Thumbnail")
				return
			}
		case "Poster":
			z.Poster, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Poster")
				return
			}
		case "TvShowPoster":
			z.TvShowPoster, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TvShowPoster")
				return
			}
		case "Banner":
			z.Banner, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Banner")
				return
			}
		case "FanArt":
			z.FanArt, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FanArt")
				return
			}
		case "FanArts":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FanArts")
				return
			}
			if cap(z.FanArts) >= int(zb0002) {
				z.FanArts = (z.FanArts)[:zb0002]
			} else {
				z.FanArts = make([]string, zb0002)
			}
			for za0001 := range z.FanArts {
				z.FanArts[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FanArts", za0001)
					return
				}
			}
		case "ClearArt":
			z.ClearArt, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClearArt")
				return
			}
		case "ClearLogo":
			z.ClearLogo, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClearLogo")
				return
			}
		case "Landscape":
			z.Landscape, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Landscape")
				return
			}
		case "Icon":
			z.Icon, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Icon")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ListItemArt) Msgsize() (s int) {
	s = 1 + 10 + msgp.StringPrefixSize + len(z.Thumbnail) + 7 + msgp.StringPrefixSize + len(z.Poster) + 13 + msgp.StringPrefixSize + len(z.TvShowPoster) + 7 + msgp.StringPrefixSize + len(z.Banner) + 7 + msgp.StringPrefixSize + len(z.FanArt) + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.FanArts {
		s += msgp.StringPrefixSize + len(z.FanArts[za0001])
	}
	s += 9 + msgp.StringPrefixSize + len(z.ClearArt) + 10 + msgp.StringPrefixSize + len(z.ClearLogo) + 10 + msgp.StringPrefixSize + len(z.Landscape) + 5 + msgp.StringPrefixSize + len(z.Icon)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ListItemCastMember) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "Name"
	o = append(o, 0x84, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "Role"
	o = append(o, 0xa4, 0x52, 0x6f, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Role)
	// string "Thumbnail"
	o = append(o, 0xa9, 0x54, 0x68, 0x75, 0x6d, 0x62, 0x6e, 0x61, 0x69, 0x6c)
	o = msgp.AppendString(o, z.Thumbnail)
	// string "Order"
	o = append(o, 0xa5, 0x4f, 0x72, 0x64, 0x65, 0x72)
	o = msgp.AppendInt(o, z.Order)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ListItemCastMember) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "Role":
			z.Role, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Role")
				return
			}
		case "Thumbnail":
			z.Thumbnail, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Thumbnail")
				return
			}
		case "Order":
			z.Order, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Order")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ListItemCastMember) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 5 + msgp.StringPrefixSize + len(z.Role) + 10 + msgp.StringPrefixSize + len(z.Thumbnail) + 6 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ListItemInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 43
	// string "Count"
	o = append(o, 0xde, 0x0, 0x2b, 0xa5, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.Count)
	// string "Size"
	o = append(o, 0xa4, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.Size)
	// string "Date"
	o = append(o, 0xa4, 0x44, 0x61, 0x74, 0x65)
	o = msgp.AppendString(o, z.Date)
	// string "Genre"
	o = append(o, 0xa5, 0x47, 0x65, 0x6e, 0x72, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Genre)))
	for za0001 := range z.Genre {
		o = msgp.AppendString(o, z.Genre[za0001])
	}
	// string "Country"
	o = append(o, 0xa7, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Country)))
	for za0002 := range z.Country {
		o = msgp.AppendString(o, z.Country[za0002])
	}
	// string "Year"
	o = append(o, 0xa4, 0x59, 0x65, 0x61, 0x72)
	o = msgp.AppendInt(o, z.Year)
	// string "Episode"
	o = append(o, 0xa7, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65)
	o = msgp.AppendInt(o, z.Episode)
	// string "Season"
	o = append(o, 0xa6, 0x53, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Season)
	// string "Top250"
	o = append(o, 0xa6, 0x54, 0x6f, 0x70, 0x32, 0x35, 0x30)
	o = msgp.AppendInt(o, z.Top250)
	// string "TrackNumber"
	o = append(o, 0xab, 0x54, 0x72, 0x61, 0x63, 0x6b, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	o = msgp.AppendInt(o, z.TrackNumber)
	// string "Rating"
	o = append(o, 0xa6, 0x52, 0x61, 0x74, 0x69, 0x6e, 0x67)
	o = msgp.AppendFloat32(o, z.Rating)
	// string "PlayCount"
	o = append(o, 0xa9, 0x50, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.PlayCount)
	// string "Overlay"
	o = append(o, 0xa7, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x79)
	o = msgp.AppendInt(o, int(z.Overlay))
	// string "Director"
	o = append(o, 0xa8, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Director)))
	for za0003 := range z.Director {
		o = msgp.AppendString(o, z.Director[za0003])
	}
	// string "MPAA"
	o = append(o, 0xa4, 0x4d, 0x50, 0x41, 0x41)
	o = msgp.AppendString(o, z.MPAA)
	// string "Plot"
	o = append(o, 0xa4, 0x50, 0x6c, 0x6f, 0x74)
	o = msgp.AppendString(o, z.Plot)
	// string "PlotOutline"
	o = append(o, 0xab, 0x50, 0x6c, 0x6f, 0x74, 0x4f, 0x75, 0x74, 0x6c, 0x69, 0x6e, 0x65)
	o = msgp.AppendString(o, z.PlotOutline)
	// string "Title"
	o = append(o, 0xa5, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Title)
	// string "OriginalTitle"
	o = append(o, 0xad, 0x4f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.OriginalTitle)
	// string "SortTitle"
	o = append(o, 0xa9, 0x53, 0x6f, 0x72, 0x74, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.SortTitle)
	// string "Duration"
	o = append(o, 0xa8, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Duration)
	// string "Studio"
	o = append(o, 0xa6, 0x53, 0x74, 0x75, 0x64, 0x69, 0x6f)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Studio)))
	for za0004 := range z.Studio {
		o = msgp.AppendString(o, z.Studio[za0004])
	}
	// string "TagLine"
	o = append(o, 0xa7, 0x54, 0x61, 0x67, 0x4c, 0x69, 0x6e, 0x65)
	o = msgp.AppendString(o, z.TagLine)
	// string "Writer"
	o = append(o, 0xa6, 0x57, 0x72, 0x69, 0x74, 0x65, 0x72)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Writer)))
	for za0005 := range z.Writer {
		o = msgp.AppendString(o, z.Writer[za0005])
	}
	// string "TVShowTitle"
	o = append(o, 0xab, 0x54, 0x56, 0x53, 0x68, 0x6f, 0x77, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.TVShowTitle)
	// string "Premiered"
	o = append(o, 0xa9, 0x50, 0x72, 0x65, 0x6d, 0x69, 0x65, 0x72, 0x65, 0x64)
	o = msgp.AppendString(o, z.Premiered)
	// string "Status"
	o = append(o, 0xa6, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
	o = msgp.AppendString(o, z.Status)
	// string "Code"
	o = append(o, 0xa4, 0x43, 0x6f, 0x64, 0x65)
	o = msgp.AppendString(o, z.Code)
	// string "Aired"
	o = append(o, 0xa5, 0x41, 0x69, 0x72, 0x65, 0x64)
	o = msgp.AppendString(o, z.Aired)
	// string "Credits"
	o = append(o, 0xa7, 0x43, 0x72, 0x65, 0x64, 0x69, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Credits)))
	for za0006 := range z.Credits {
		o = msgp.AppendString(o, z.Credits[za0006])
	}
	// string "LastPlayed"
	o = append(o, 0xaa, 0x4c, 0x61, 0x73, 0x74, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x64)
	o = msgp.AppendString(o, z.LastPlayed)
	// string "Album"
	o = append(o, 0xa5, 0x41, 0x6c, 0x62, 0x75, 0x6d)
	o = msgp.AppendString(o, z.Album)
	// string "Artist"
	o = append(o, 0xa6, 0x41, 0x72, 0x74, 0x69, 0x73, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Artist)))
	for za0007 := range z.Artist {
		o = msgp.AppendString(o, z.Artist[za0007])
	}
	// string "Votes"
	o = append(o, 0xa5, 0x56, 0x6f, 0x74, 0x65, 0x73)
	o = msgp.AppendString(o, z.Votes)
	// string "Trailer"
	o = append(o, 0xa7, 0x54, 0x72, 0x61, 0x69, 0x6c, 0x65, 0x72)
	o = msgp.AppendString(o, z.Trailer)
	// string "DateAdded"
	o = append(o, 0xa9, 0x44, 0x61, 0x74, 0x65, 0x41, 0x64, 0x64, 0x65, 0x64)
	o = msgp.AppendString(o, z.DateAdded)
	// string "DBID"
	o = append(o, 0xa4, 0x44, 0x42, 0x49, 0x44)
	o = msgp.AppendInt(o, z.DBID)
	// string "DBTYPE"
	o = append(o, 0xa6, 0x44, 0x42, 0x54, 0x59, 0x50, 0x45)
	o = msgp.AppendString(o, z.DBTYPE)
	// string "Mediatype"
	o = append(o, 0xa9, 0x4d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Mediatype)
	// string "IMDBNumber"
	o = append(o, 0xaa, 0x49, 0x4d, 0x44, 0x42, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	o = msgp.AppendString(o, z.IMDBNumber)
	// string "Lyrics"
	o = append(o, 0xa6, 0x4c, 0x79, 0x72, 0x69, 0x63, 0x73)
	o = msgp.AppendString(o, z.Lyrics)
	// string "PicturePath"
	o = append(o, 0xab, 0x50, 0x69, 0x63, 0x74, 0x75, 0x72, 0x65, 0x50, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.PicturePath)
	// string "Exif"
	o = append(o, 0xa4, 0x45, 0x78, 0x69, 0x66)
	o = msgp.AppendString(o, z.Exif)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ListItemInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Count":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "Size":
			z.Size, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "Date":
			z.Date, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Date")
				return
			}
		case "Genre":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Genre")
				return
			}
			if cap(z.Genre) >= int(zb0002) {
				z.Genre = (z.Genre)[:zb0002]
			} else {
				z.Genre = make([]string, zb0002)
			}
			for za0001 := range z.Genre {
				z.Genre[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Genre", za0001)
					return
				}
			}
		case "Country":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Country")
				return
			}
			if cap(z.Country) >= int(zb0003) {
				z.Country = (z.Country)[:zb0003]
			} else {
				z.Country = make([]string, zb0003)
			}
			for za0002 := range z.Country {
				z.Country[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Country", za0002)
					return
				}
			}
		case "Year":
			z.Year, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Year")
				return
			}
		case "Episode":
			z.Episode, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Episode")
				return
			}
		case "Season":
			z.Season, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Season")
				return
			}
		case "Top250":
			z.Top250, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Top250")
				return
			}
		case "TrackNumber":
			z.TrackNumber, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TrackNumber")
				return
			}
		case "Rating":
			z.Rating, bts, err = msgp.ReadFloat32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Rating")
				return
			}
		case "PlayCount":
			z.PlayCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlayCount")
				return
			}
		case "Overlay":
			{
				var zb0004 int
				zb0004, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Overlay")
					return
				}
				z.Overlay = GUIIconOverlay(zb0004)
			}
		case "Director":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Director")
				return
			}
			if cap(z.Director) >= int(zb0005) {
				z.Director = (z.Director)[:zb0005]
			} else {
				z.Director = make([]string, zb0005)
			}
			for za0003 := range z.Director {
				z.Director[za0003], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Director", za0003)
					return
				}
			}
		case "MPAA":
			z.MPAA, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MPAA")
				return
			}
		case "Plot":
			z.Plot, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Plot")
				return
			}
		case "PlotOutline":
			z.PlotOutline, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlotOutline")
				return
			}
		case "Title":
			z.Title, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Title")
				return
			}
		case "OriginalTitle":
			z.OriginalTitle, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OriginalTitle")
				return
			}
		case "SortTitle":
			z.SortTitle, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SortTitle")
				return
			}
		case "Duration":
			z.Duration, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Duration")
				return
			}
		case "Studio":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Studio")
				return
			}
			if cap(z.Studio) >= int(zb0006) {
				z.Studio = (z.Studio)[:zb0006]
			} else {
				z.Studio = make([]string, zb0006)
			}
			for za0004 := range z.Studio {
				z.Studio[za0004], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Studio", za0004)
					return
				}
			}
		case "TagLine":
			z.TagLine, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TagLine")
				return
			}
		case "Writer":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Writer")
				return
			}
			if cap(z.Writer) >= int(zb0007) {
				z.Writer = (z.Writer)[:zb0007]
			} else {
				z.Writer = make([]string, zb0007)
			}
			for za0005 := range z.Writer {
				z.Writer[za0005], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Writer", za0005)
					return
				}
			}
		case "TVShowTitle":
			z.TVShowTitle, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TVShowTitle")
				return
			}
		case "Premiered":
			z.Premiered, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Premiered")
				return
			}
		case "Status":
			z.Status, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "Code":
			z.Code, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Code")
				return
			}
		case "Aired":
			z.Aired, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Aired")
				return
			}
		case "Credits":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Credits")
				return
			}
			if cap(z.Credits) >= int(zb0008) {
				z.Credits = (z.Credits)[:zb0008]
			} else {
				z.Credits = make([]string, zb0008)
			}
			for za0006 := range z.Credits {
				z.Credits[za0006], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Credits", za0006)
					return
				}
			}
		case "LastPlayed":
			z.LastPlayed, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastPlayed")
				return
			}
		case "Album":
			z.Album, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Album")
				return
			}
		case "Artist":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Artist")
				return
			}
			if cap(z.Artist) >= int(zb0009) {
				z.Artist = (z.Artist)[:zb0009]
			} else {
				z.Artist = make([]string, zb0009)
			}
			for za0007 := range z.Artist {
				z.Artist[za0007], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Artist", za0007)
					return
				}
			}
		case "Votes":
			z.Votes, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Votes")
				return
			}
		case "Trailer":
			z.Trailer, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Trailer")
				return
			}
		case "DateAdded":
			z.DateAdded, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DateAdded")
				return
			}
		case "DBID":
			z.DBID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DBID")
				return
			}
		case "DBTYPE":
			z.DBTYPE, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DBTYPE")
				return
			}
		case "Mediatype":
			z.Mediatype, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mediatype")
				return
			}
		case "IMDBNumber":
			z.IMDBNumber, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IMDBNumber")
				return
			}
		case "Lyrics":
			z.Lyrics, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lyrics")
				return
			}
		case "PicturePath":
			z.PicturePath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PicturePath")
				return
			}
		case "Exif":
			z.Exif, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Exif")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ListItemInfo) Msgsize() (s int) {
	s = 3 + 6 + msgp.IntSize + 5 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Date) + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Genre {
		s += msgp.StringPrefixSize + len(z.Genre[za0001])
	}
	s += 8 + msgp.ArrayHeaderSize
	for za0002 := range z.Country {
		s += msgp.StringPrefixSize + len(z.Country[za0002])
	}
	s += 5 + msgp.IntSize + 8 + msgp.IntSize + 7 + msgp.IntSize + 7 + msgp.IntSize + 12 + msgp.IntSize + 7 + msgp.Float32Size + 10 + msgp.IntSize + 8 + msgp.IntSize + 9 + msgp.ArrayHeaderSize
	for za0003 := range z.Director {
		s += msgp.StringPrefixSize + len(z.Director[za0003])
	}
	s += 5 + msgp.StringPrefixSize + len(z.MPAA) + 5 + msgp.StringPrefixSize + len(z.Plot) + 12 + msgp.StringPrefixSize + len(z.PlotOutline) + 6 + msgp.StringPrefixSize + len(z.Title) + 14 + msgp.StringPrefixSize + len(z.OriginalTitle) + 10 + msgp.StringPrefixSize + len(z.SortTitle) + 9 + msgp.IntSize + 7 + msgp.ArrayHeaderSize
	for za0004 := range z.Studio {
		s += msgp.StringPrefixSize + len(z.Studio[za0004])
	}
	s += 8 + msgp.StringPrefixSize + len(z.TagLine) + 7 + msgp.ArrayHeaderSize
	for za0005 := range z.Writer {
		s += msgp.StringPrefixSize + len(z.Writer[za0005])
	}
	s += 12 + msgp.StringPrefixSize + len(z.TVShowTitle) + 10 + msgp.StringPrefixSize + len(z.Premiered) + 7 + msgp.StringPrefixSize + len(z.Status) + 5 + msgp.StringPrefixSize + len(z.Code) + 6 + msgp.StringPrefixSize + len(z.Aired) + 8 + msgp.ArrayHeaderSize
	for za0006 := range z.Credits {
		s += msgp.StringPrefixSize + len(z.Credits[za0006])
	}
	s += 11 + msgp.StringPrefixSize + len(z.LastPlayed) + 6 + msgp.StringPrefixSize + len(z.Album) + 7 + msgp.ArrayHeaderSize
	for za0007 := range z.Artist {
		s += msgp.StringPrefixSize + len(z.Artist[za0007])
	}
	s += 6 + msgp.StringPrefixSize + len(z.Votes) + 8 + msgp.StringPrefixSize + len(z.Trailer) + 10 + msgp.StringPrefixSize + len(z.DateAdded) + 5 + msgp.IntSize + 7 + msgp.StringPrefixSize + len(z.DBTYPE) + 10 + msgp.StringPrefixSize + len(z.Mediatype) + 11 + msgp.StringPrefixSize + len(z.IMDBNumber) + 7 + msgp.StringPrefixSize + len(z.Lyrics) + 12 + msgp.StringPrefixSize + len(z.PicturePath) + 5 + msgp.StringPrefixSize + len(z.Exif)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ListItemProperties) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "TotalSeasons"
	o = append(o, 0x86, 0xac, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x73)
	o = msgp.AppendString(o, z.TotalSeasons)
	// string "TotalEpisodes"
	o = append(o, 0xad, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendString(o, z.TotalEpisodes)
	// string "WatchedEpisodes"
	o = append(o, 0xaf, 0x57, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendString(o, z.WatchedEpisodes)
	// string "UnWatchedEpisodes"
	o = append(o, 0xb1, 0x55, 0x6e, 0x57, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendString(o, z.UnWatchedEpisodes)
	// string "SubtitlesSync"
	o = append(o, 0xad, 0x53, 0x75, 0x62, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x73, 0x53, 0x79, 0x6e, 0x63)
	o = msgp.AppendString(o, z.SubtitlesSync)
	// string "SubtitlesHearingImpaired"
	o = append(o, 0xb8, 0x53, 0x75, 0x62, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x73, 0x48, 0x65, 0x61, 0x72, 0x69, 0x6e, 0x67, 0x49, 0x6d, 0x70, 0x61, 0x69, 0x72, 0x65, 0x64)
	o = msgp.AppendString(o, z.SubtitlesHearingImpaired)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ListItemProperties) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "TotalSeasons":
			z.TotalSeasons, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalSeasons")
				return
			}
		case "TotalEpisodes":
			z.TotalEpisodes, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalEpisodes")
				return
			}
		case "WatchedEpisodes":
			z.WatchedEpisodes, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WatchedEpisodes")
				return
			}
		case "UnWatchedEpisodes":
			z.UnWatchedEpisodes, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UnWatchedEpisodes")
				return
			}
		case "SubtitlesSync":
			z.SubtitlesSync, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SubtitlesSync")
				return
			}
		case "SubtitlesHearingImpaired":
			z.SubtitlesHearingImpaired, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SubtitlesHearingImpaired")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ListItemProperties) Msgsize() (s int) {
	s = 1 + 13 + msgp.StringPrefixSize + len(z.TotalSeasons) + 14 + msgp.StringPrefixSize + len(z.TotalEpisodes) + 16 + msgp.StringPrefixSize + len(z.WatchedEpisodes) + 18 + msgp.StringPrefixSize + len(z.UnWatchedEpisodes) + 14 + msgp.StringPrefixSize + len(z.SubtitlesSync) + 25 + msgp.StringPrefixSize + len(z.SubtitlesHearingImpaired)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ListItems) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendArrayHeader(o, uint32(len(z)))
	for za0001 := range z {
		if z[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ListItems) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0002 uint32
	zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if cap((*z)) >= int(zb0002) {
		(*z) = (*z)[:zb0002]
	} else {
		(*z) = make(ListItems, zb0002)
	}
	for zb0001 := range *z {
		if msgp.IsNil(bts) {
			bts, err = msgp.ReadNilBytes(bts)
			if err != nil {
				return
			}
			(*z)[zb0001] = nil
		} else {
			if (*z)[zb0001] == nil {
				(*z)[zb0001] = new(ListItem)
			}
			bts, err = (*z)[zb0001].UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ListItems) Msgsize() (s int) {
	s = msgp.ArrayHeaderSize
	for zb0003 := range z {
		if z[zb0003] == nil {
			s += msgp.NilSize
		} else {
			s += z[zb0003].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PlayerItemInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Info"
	o = append(o, 0x81, 0xa4, 0x49, 0x6e, 0x66, 0x6f)
	// map header, size 2
	// string "ID"
	o = append(o, 0x82, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt(o, z.Info.ID)
	// string "Type"
	o = append(o, 0xa4, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.Info.Type)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PlayerItemInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Info":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Info")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Info")
					return
				}
				switch msgp.UnsafeString(field) {
				case "ID":
					z.Info.ID, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Info", "ID")
						return
					}
				case "Type":
					z.Info.Type, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Info", "Type")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Info")
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PlayerItemInfo) Msgsize() (s int) {
	s = 1 + 5 + 1 + 3 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Info.Type)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Resume) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Position"
	o = append(o, 0x82, 0xa8, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendFloat64(o, z.Position)
	// string "Total"
	o = append(o, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
	o = msgp.AppendFloat64(o, z.Total)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Resume) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Position":
			z.Position, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Position")
				return
			}
		case "Total":
			z.Total, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Resume) Msgsize() (s int) {
	s = 1 + 9 + msgp.Float64Size + 6 + msgp.Float64Size
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SettingValue) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Value"
	o = append(o, 0x81, 0xa5, 0x56, 0x61, 0x6c, 0x75, 0x65)
	o = msgp.AppendString(o, z.Value)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SettingValue) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Value":
			z.Value, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Value")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SettingValue) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Value)
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StreamInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Video"
	o = append(o, 0x83, 0xa5, 0x56, 0x69, 0x64, 0x65, 0x6f)
	if z.Video == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Video.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Video")
			return
		}
	}
	// string "Audio"
	o = append(o, 0xa5, 0x41, 0x75, 0x64, 0x69, 0x6f)
	if z.Audio == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Audio.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Audio")
			return
		}
	}
	// string "Subtitle"
	o = append(o, 0xa8, 0x53, 0x75, 0x62, 0x74, 0x69, 0x74, 0x6c, 0x65)
	if z.Subtitle == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Subtitle.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Subtitle")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StreamInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Video":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Video = nil
			} else {
				if z.Video == nil {
					z.Video = new(StreamInfoEntry)
				}
				bts, err = z.Video.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Video")
					return
				}
			}
		case "Audio":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Audio = nil
			} else {
				if z.Audio == nil {
					z.Audio = new(StreamInfoEntry)
				}
				bts, err = z.Audio.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Audio")
					return
				}
			}
		case "Subtitle":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Subtitle = nil
			} else {
				if z.Subtitle == nil {
					z.Subtitle = new(StreamInfoEntry)
				}
				bts, err = z.Subtitle.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Subtitle")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StreamInfo) Msgsize() (s int) {
	s = 1 + 6
	if z.Video == nil {
		s += msgp.NilSize
	} else {
		s += z.Video.Msgsize()
	}
	s += 6
	if z.Audio == nil {
		s += msgp.NilSize
	} else {
		s += z.Audio.Msgsize()
	}
	s += 9
	if z.Subtitle == nil {
		s += msgp.NilSize
	} else {
		s += z.Subtitle.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StreamInfoEntry) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "Codec"
	o = append(o, 0x87, 0xa5, 0x43, 0x6f, 0x64, 0x65, 0x63)
	o = msgp.AppendString(o, z.Codec)
	// string "Aspect"
	o = append(o, 0xa6, 0x41, 0x73, 0x70, 0x65, 0x63, 0x74)
	o = msgp.AppendFloat32(o, z.Aspect)
	// string "Width"
	o = append(o, 0xa5, 0x57, 0x69, 0x64, 0x74, 0x68)
	o = msgp.AppendInt(o, z.Width)
	// string "Height"
	o = append(o, 0xa6, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74)
	o = msgp.AppendInt(o, z.Height)
	// string "Duration"
	o = append(o, 0xa8, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Duration)
	// string "Language"
	o = append(o, 0xa8, 0x4c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65)
	o = msgp.AppendString(o, z.Language)
	// string "Channels"
	o = append(o, 0xa8, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x73)
	o = msgp.AppendInt(o, z.Channels)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StreamInfoEntry) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Codec":
			z.Codec, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Codec")
				return
			}
		case "Aspect":
			z.Aspect, bts, err = msgp.ReadFloat32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Aspect")
				return
			}
		case "Width":
			z.Width, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Width")
				return
			}
		case "Height":
			z.Height, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Height")
				return
			}
		case "Duration":
			z.Duration, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Duration")
				return
			}
		case "Language":
			z.Language, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Language")
				return
			}
		case "Channels":
			z.Channels, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Channels")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StreamInfoEntry) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Codec) + 7 + msgp.Float32Size + 6 + msgp.IntSize + 7 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.StringPrefixSize + len(z.Language) + 9 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *UniqueIDs) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "Unknown"
	o = append(o, 0x88, 0xa7, 0x55, 0x6e, 0x6b, 0x6e, 0x6f, 0x77, 0x6e)
	o = msgp.AppendString(o, z.Unknown)
	// string "TMDB"
	o = append(o, 0xa4, 0x54, 0x4d, 0x44, 0x42)
	o = msgp.AppendString(o, z.TMDB)
	// string "TVDB"
	o = append(o, 0xa4, 0x54, 0x56, 0x44, 0x42)
	o = msgp.AppendString(o, z.TVDB)
	// string "IMDB"
	o = append(o, 0xa4, 0x49, 0x4d, 0x44, 0x42)
	o = msgp.AppendString(o, z.IMDB)
	// string "TheMovieDB"
	o = append(o, 0xaa, 0x54, 0x68, 0x65, 0x4d, 0x6f, 0x76, 0x69, 0x65, 0x44, 0x42)
	o = msgp.AppendString(o, z.TheMovieDB)
	// string "Trakt"
	o = append(o, 0xa5, 0x54, 0x72, 0x61, 0x6b, 0x74)
	o = msgp.AppendString(o, z.Trakt)
	// string "Elementum"
	o = append(o, 0xa9, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x75, 0x6d)
	o = msgp.AppendString(o, z.Elementum)
	// string "Kodi"
	o = append(o, 0xa4, 0x4b, 0x6f, 0x64, 0x69)
	o = msgp.AppendInt(o, z.Kodi)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *UniqueIDs) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Unknown":
			z.Unknown, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Unknown")
				return
			}
		case "TMDB":
			z.TMDB, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TMDB")
				return
			}
		case "TVDB":
			z.TVDB, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TVDB")
				return
			}
		case "IMDB":
			z.IMDB, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IMDB")
				return
			}
		case "TheMovieDB":
			z.TheMovieDB, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TheMovieDB")
				return
			}
		case "Trakt":
			z.Trakt, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Trakt")
				return
			}
		case "Elementum":
			z.Elementum, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Elementum")
				return
			}
		case "Kodi":
			z.Kodi, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Kodi")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *UniqueIDs) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Unknown) + 5 + msgp.StringPrefixSize + len(z.TMDB) + 5 + msgp.StringPrefixSize + len(z.TVDB) + 5 + msgp.StringPrefixSize + len(z.IMDB) + 11 + msgp.StringPrefixSize + len(z.TheMovieDB) + 6 + msgp.StringPrefixSize + len(z.Trakt) + 10 + msgp.StringPrefixSize + len(z.Elementum) + 5 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryEpisode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Episode"
	o = append(o, 0x81, 0xa7, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65)
	if z.Episode == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Episode.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Episode")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryEpisode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Episode":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Episode = nil
			} else {
				if z.Episode == nil {
					z.Episode = new(VideoLibraryEpisodeItem)
				}
				bts, err = z.Episode.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Episode")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryEpisode) Msgsize() (s int) {
	s = 1 + 8
	if z.Episode == nil {
		s += msgp.NilSize
	} else {
		s += z.Episode.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryEpisodeItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "ID"
	o = append(o, 0x8a, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt(o, z.ID)
	// string "Title"
	o = append(o, 0xa5, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Title)
	// string "Season"
	o = append(o, 0xa6, 0x53, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Season)
	// string "Episode"
	o = append(o, 0xa7, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65)
	o = msgp.AppendInt(o, z.Episode)
	// string "TVShowID"
	o = append(o, 0xa8, 0x54, 0x56, 0x53, 0x68, 0x6f, 0x77, 0x49, 0x44)
	o = msgp.AppendInt(o, z.TVShowID)
	// string "PlayCount"
	o = append(o, 0xa9, 0x50, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.PlayCount)
	// string "File"
	o = append(o, 0xa4, 0x46, 0x69, 0x6c, 0x65)
	o = msgp.AppendString(o, z.File)
	// string "DateAdded"
	o = append(o, 0xa9, 0x44, 0x61, 0x74, 0x65, 0x41, 0x64, 0x64, 0x65, 0x64)
	// map header, size 1
	// string "Time"
	o = append(o, 0x81, 0xa4, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.DateAdded.Time)
	// string "UniqueIDs"
	o = append(o, 0xa9, 0x55, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x44, 0x73)
	o, err = z.UniqueIDs.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "UniqueIDs")
		return
	}
	// string "Resume"
	o = append(o, 0xa6, 0x52, 0x65, 0x73, 0x75, 0x6d, 0x65)
	if z.Resume == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "Position"
		o = append(o, 0x82, 0xa8, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e)
		o = msgp.AppendFloat64(o, z.Resume.Position)
		// string "Total"
		o = append(o, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
		o = msgp.AppendFloat64(o, z.Resume.Total)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryEpisodeItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Title":
			z.Title, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Title")
				return
			}
		case "Season":
			z.Season, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Season")
				return
			}
		case "Episode":
			z.Episode, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Episode")
				return
			}
		case "TVShowID":
			z.TVShowID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TVShowID")
				return
			}
		case "PlayCount":
			z.PlayCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlayCount")
				return
			}
		case "File":
			z.File, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "File")
				return
			}
		case "DateAdded":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DateAdded")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "DateAdded")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Time":
					z.DateAdded.Time, bts, err = msgp.ReadTimeBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "DateAdded", "Time")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "DateAdded")
						return
					}
				}
			}
		case "UniqueIDs":
			bts, err = z.UniqueIDs.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "UniqueIDs")
				return
			}
		case "Resume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Resume = nil
			} else {
				if z.Resume == nil {
					z.Resume = new(Resume)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Resume")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Resume")
						return
					}
					switch msgp.UnsafeString(field) {
					case "Position":
						z.Resume.Position, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Resume", "Position")
							return
						}
					case "Total":
						z.Resume.Total, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Resume", "Total")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Resume")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryEpisodeItem) Msgsize() (s int) {
	s = 1 + 3 + msgp.IntSize + 6 + msgp.StringPrefixSize + len(z.Title) + 7 + msgp.IntSize + 8 + msgp.IntSize + 9 + msgp.IntSize + 10 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.File) + 10 + 1 + 5 + msgp.TimeSize + 10 + z.UniqueIDs.Msgsize() + 7
	if z.Resume == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 9 + msgp.Float64Size + 6 + msgp.Float64Size
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryEpisodes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Episodes"
	o = append(o, 0x81, 0xa8, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Episodes)))
	for za0001 := range z.Episodes {
		if z.Episodes[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Episodes[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Episodes", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryEpisodes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Episodes":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Episodes")
				return
			}
			if cap(z.Episodes) >= int(zb0002) {
				z.Episodes = (z.Episodes)[:zb0002]
			} else {
				z.Episodes = make([]*VideoLibraryEpisodeItem, zb0002)
			}
			for za0001 := range z.Episodes {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Episodes[za0001] = nil
				} else {
					if z.Episodes[za0001] == nil {
						z.Episodes[za0001] = new(VideoLibraryEpisodeItem)
					}
					bts, err = z.Episodes[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Episodes", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryEpisodes) Msgsize() (s int) {
	s = 1 + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Episodes {
		if z.Episodes[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Episodes[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z VideoLibraryLimits) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "End"
	o = append(o, 0x83, 0xa3, 0x45, 0x6e, 0x64)
	o = msgp.AppendInt(o, z.End)
	// string "Start"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x72, 0x74)
	o = msgp.AppendInt(o, z.Start)
	// string "Total"
	o = append(o, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
	o = msgp.AppendInt(o, z.Total)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryLimits) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "End":
			z.End, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "End")
				return
			}
		case "Start":
			z.Start, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Start")
				return
			}
		case "Total":
			z.Total, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z VideoLibraryLimits) Msgsize() (s int) {
	s = 1 + 4 + msgp.IntSize + 6 + msgp.IntSize + 6 + msgp.IntSize
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryMovieItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "ID"
	o = append(o, 0x89, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt(o, z.ID)
	// string "Title"
	o = append(o, 0xa5, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Title)
	// string "IMDBNumber"
	o = append(o, 0xaa, 0x49, 0x4d, 0x44, 0x42, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	o = msgp.AppendString(o, z.IMDBNumber)
	// string "PlayCount"
	o = append(o, 0xa9, 0x50, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.PlayCount)
	// string "File"
	o = append(o, 0xa4, 0x46, 0x69, 0x6c, 0x65)
	o = msgp.AppendString(o, z.File)
	// string "Year"
	o = append(o, 0xa4, 0x59, 0x65, 0x61, 0x72)
	o = msgp.AppendInt(o, z.Year)
	// string "DateAdded"
	o = append(o, 0xa9, 0x44, 0x61, 0x74, 0x65, 0x41, 0x64, 0x64, 0x65, 0x64)
	// map header, size 1
	// string "Time"
	o = append(o, 0x81, 0xa4, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.DateAdded.Time)
	// string "UniqueIDs"
	o = append(o, 0xa9, 0x55, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x44, 0x73)
	o, err = z.UniqueIDs.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "UniqueIDs")
		return
	}
	// string "Resume"
	o = append(o, 0xa6, 0x52, 0x65, 0x73, 0x75, 0x6d, 0x65)
	if z.Resume == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 2
		// string "Position"
		o = append(o, 0x82, 0xa8, 0x50, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e)
		o = msgp.AppendFloat64(o, z.Resume.Position)
		// string "Total"
		o = append(o, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
		o = msgp.AppendFloat64(o, z.Resume.Total)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryMovieItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Title":
			z.Title, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Title")
				return
			}
		case "IMDBNumber":
			z.IMDBNumber, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IMDBNumber")
				return
			}
		case "PlayCount":
			z.PlayCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlayCount")
				return
			}
		case "File":
			z.File, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "File")
				return
			}
		case "Year":
			z.Year, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Year")
				return
			}
		case "DateAdded":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DateAdded")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "DateAdded")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Time":
					z.DateAdded.Time, bts, err = msgp.ReadTimeBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "DateAdded", "Time")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "DateAdded")
						return
					}
				}
			}
		case "UniqueIDs":
			bts, err = z.UniqueIDs.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "UniqueIDs")
				return
			}
		case "Resume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Resume = nil
			} else {
				if z.Resume == nil {
					z.Resume = new(Resume)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Resume")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Resume")
						return
					}
					switch msgp.UnsafeString(field) {
					case "Position":
						z.Resume.Position, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Resume", "Position")
							return
						}
					case "Total":
						z.Resume.Total, bts, err = msgp.ReadFloat64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Resume", "Total")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Resume")
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryMovieItem) Msgsize() (s int) {
	s = 1 + 3 + msgp.IntSize + 6 + msgp.StringPrefixSize + len(z.Title) + 11 + msgp.StringPrefixSize + len(z.IMDBNumber) + 10 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.File) + 5 + msgp.IntSize + 10 + 1 + 5 + msgp.TimeSize + 10 + z.UniqueIDs.Msgsize() + 7
	if z.Resume == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 9 + msgp.Float64Size + 6 + msgp.Float64Size
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryMovies) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Limits"
	o = append(o, 0x82, 0xa6, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73)
	if z.Limits == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 3
		// string "End"
		o = append(o, 0x83, 0xa3, 0x45, 0x6e, 0x64)
		o = msgp.AppendInt(o, z.Limits.End)
		// string "Start"
		o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x72, 0x74)
		o = msgp.AppendInt(o, z.Limits.Start)
		// string "Total"
		o = append(o, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
		o = msgp.AppendInt(o, z.Limits.Total)
	}
	// string "Movies"
	o = append(o, 0xa6, 0x4d, 0x6f, 0x76, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Movies)))
	for za0001 := range z.Movies {
		if z.Movies[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Movies[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Movies", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryMovies) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Limits":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Limits = nil
			} else {
				if z.Limits == nil {
					z.Limits = new(VideoLibraryLimits)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Limits")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Limits")
						return
					}
					switch msgp.UnsafeString(field) {
					case "End":
						z.Limits.End, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Limits", "End")
							return
						}
					case "Start":
						z.Limits.Start, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Limits", "Start")
							return
						}
					case "Total":
						z.Limits.Total, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Limits", "Total")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Limits")
							return
						}
					}
				}
			}
		case "Movies":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Movies")
				return
			}
			if cap(z.Movies) >= int(zb0003) {
				z.Movies = (z.Movies)[:zb0003]
			} else {
				z.Movies = make([]*VideoLibraryMovieItem, zb0003)
			}
			for za0001 := range z.Movies {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Movies[za0001] = nil
				} else {
					if z.Movies[za0001] == nil {
						z.Movies[za0001] = new(VideoLibraryMovieItem)
					}
					bts, err = z.Movies[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Movies", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryMovies) Msgsize() (s int) {
	s = 1 + 7
	if z.Limits == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 4 + msgp.IntSize + 6 + msgp.IntSize + 6 + msgp.IntSize
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Movies {
		if z.Movies[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Movies[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibrarySeason) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Episode"
	o = append(o, 0x81, 0xa7, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65)
	if z.Episode == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Episode.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Episode")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibrarySeason) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Episode":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Episode = nil
			} else {
				if z.Episode == nil {
					z.Episode = new(VideoLibrarySeasonItem)
				}
				bts, err = z.Episode.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Episode")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibrarySeason) Msgsize() (s int) {
	s = 1 + 8
	if z.Episode == nil {
		s += msgp.NilSize
	} else {
		s += z.Episode.Msgsize()
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibrarySeasonItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "ID"
	o = append(o, 0x87, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt(o, z.ID)
	// string "Title"
	o = append(o, 0xa5, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Title)
	// string "Season"
	o = append(o, 0xa6, 0x53, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Season)
	// string "Episodes"
	o = append(o, 0xa8, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendInt(o, z.Episodes)
	// string "TVShowID"
	o = append(o, 0xa8, 0x54, 0x56, 0x53, 0x68, 0x6f, 0x77, 0x49, 0x44)
	o = msgp.AppendInt(o, z.TVShowID)
	// string "PlayCount"
	o = append(o, 0xa9, 0x50, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.PlayCount)
	// string "UniqueIDs"
	o = append(o, 0xa9, 0x55, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x44, 0x73)
	o, err = z.UniqueIDs.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "UniqueIDs")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibrarySeasonItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Title":
			z.Title, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Title")
				return
			}
		case "Season":
			z.Season, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Season")
				return
			}
		case "Episodes":
			z.Episodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Episodes")
				return
			}
		case "TVShowID":
			z.TVShowID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TVShowID")
				return
			}
		case "PlayCount":
			z.PlayCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlayCount")
				return
			}
		case "UniqueIDs":
			bts, err = z.UniqueIDs.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "UniqueIDs")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibrarySeasonItem) Msgsize() (s int) {
	s = 1 + 3 + msgp.IntSize + 6 + msgp.StringPrefixSize + len(z.Title) + 7 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 10 + msgp.IntSize + 10 + z.UniqueIDs.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibrarySeasons) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Seasons"
	o = append(o, 0x81, 0xa7, 0x53, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Seasons)))
	for za0001 := range z.Seasons {
		if z.Seasons[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Seasons[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Seasons", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibrarySeasons) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Seasons":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Seasons")
				return
			}
			if cap(z.Seasons) >= int(zb0002) {
				z.Seasons = (z.Seasons)[:zb0002]
			} else {
				z.Seasons = make([]*VideoLibrarySeasonItem, zb0002)
			}
			for za0001 := range z.Seasons {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Seasons[za0001] = nil
				} else {
					if z.Seasons[za0001] == nil {
						z.Seasons[za0001] = new(VideoLibrarySeasonItem)
					}
					bts, err = z.Seasons[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seasons", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibrarySeasons) Msgsize() (s int) {
	s = 1 + 8 + msgp.ArrayHeaderSize
	for za0001 := range z.Seasons {
		if z.Seasons[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Seasons[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryShowItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "ID"
	o = append(o, 0x88, 0xa2, 0x49, 0x44)
	o = msgp.AppendInt(o, z.ID)
	// string "Title"
	o = append(o, 0xa5, 0x54, 0x69, 0x74, 0x6c, 0x65)
	o = msgp.AppendString(o, z.Title)
	// string "IMDBNumber"
	o = append(o, 0xaa, 0x49, 0x4d, 0x44, 0x42, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
	o = msgp.AppendString(o, z.IMDBNumber)
	// string "PlayCount"
	o = append(o, 0xa9, 0x50, 0x6c, 0x61, 0x79, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.PlayCount)
	// string "Year"
	o = append(o, 0xa4, 0x59, 0x65, 0x61, 0x72)
	o = msgp.AppendInt(o, z.Year)
	// string "Episodes"
	o = append(o, 0xa8, 0x45, 0x70, 0x69, 0x73, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendInt(o, z.Episodes)
	// string "DateAdded"
	o = append(o, 0xa9, 0x44, 0x61, 0x74, 0x65, 0x41, 0x64, 0x64, 0x65, 0x64)
	// map header, size 1
	// string "Time"
	o = append(o, 0x81, 0xa4, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.DateAdded.Time)
	// string "UniqueIDs"
	o = append(o, 0xa9, 0x55, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x44, 0x73)
	o, err = z.UniqueIDs.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "UniqueIDs")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryShowItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Title":
			z.Title, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Title")
				return
			}
		case "IMDBNumber":
			z.IMDBNumber, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IMDBNumber")
				return
			}
		case "PlayCount":
			z.PlayCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlayCount")
				return
			}
		case "Year":
			z.Year, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Year")
				return
			}
		case "Episodes":
			z.Episodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Episodes")
				return
			}
		case "DateAdded":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DateAdded")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "DateAdded")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Time":
					z.DateAdded.Time, bts, err = msgp.ReadTimeBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "DateAdded", "Time")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "DateAdded")
						return
					}
				}
			}
		case "UniqueIDs":
			bts, err = z.UniqueIDs.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "UniqueIDs")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryShowItem) Msgsize() (s int) {
	s = 1 + 3 + msgp.IntSize + 6 + msgp.StringPrefixSize + len(z.Title) + 11 + msgp.StringPrefixSize + len(z.IMDBNumber) + 10 + msgp.IntSize + 5 + msgp.IntSize + 9 + msgp.IntSize + 10 + 1 + 5 + msgp.TimeSize + 10 + z.UniqueIDs.Msgsize()
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VideoLibraryShows) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Limits"
	o = append(o, 0x82, 0xa6, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73)
	if z.Limits == nil {
		o = msgp.AppendNil(o)
	} else {
		// map header, size 3
		// string "End"
		o = append(o, 0x83, 0xa3, 0x45, 0x6e, 0x64)
		o = msgp.AppendInt(o, z.Limits.End)
		// string "Start"
		o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x72, 0x74)
		o = msgp.AppendInt(o, z.Limits.Start)
		// string "Total"
		o = append(o, 0xa5, 0x54, 0x6f, 0x74, 0x61, 0x6c)
		o = msgp.AppendInt(o, z.Limits.Total)
	}
	// string "Shows"
	o = append(o, 0xa5, 0x53, 0x68, 0x6f, 0x77, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Shows)))
	for za0001 := range z.Shows {
		if z.Shows[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Shows[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Shows", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VideoLibraryShows) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Limits":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Limits = nil
			} else {
				if z.Limits == nil {
					z.Limits = new(VideoLibraryLimits)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Limits")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Limits")
						return
					}
					switch msgp.UnsafeString(field) {
					case "End":
						z.Limits.End, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Limits", "End")
							return
						}
					case "Start":
						z.Limits.Start, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Limits", "Start")
							return
						}
					case "Total":
						z.Limits.Total, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Limits", "Total")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Limits")
							return
						}
					}
				}
			}
		case "Shows":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Shows")
				return
			}
			if cap(z.Shows) >= int(zb0003) {
				z.Shows = (z.Shows)[:zb0003]
			} else {
				z.Shows = make([]*VideoLibraryShowItem, zb0003)
			}
			for za0001 := range z.Shows {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Shows[za0001] = nil
				} else {
					if z.Shows[za0001] == nil {
						z.Shows[za0001] = new(VideoLibraryShowItem)
					}
					bts, err = z.Shows[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Shows", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VideoLibraryShows) Msgsize() (s int) {
	s = 1 + 7
	if z.Limits == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 4 + msgp.IntSize + 6 + msgp.IntSize + 6 + msgp.IntSize
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Shows {
		if z.Shows[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Shows[za0001].Msgsize()
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *View) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "ContentType"
	o = append(o, 0x82, 0xab, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.ContentType)
	// string "Items"
	o = append(o, 0xa5, 0x49, 0x74, 0x65, 0x6d, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Items)))
	for za0001 := range z.Items {
		if z.Items[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Items[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Items", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *View) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ContentType":
			z.ContentType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ContentType")
				return
			}
		case "Items":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Items")
				return
			}
			if cap(z.Items) >= int(zb0002) {
				z.Items = (z.Items)[:zb0002]
			} else {
				z.Items = make(ListItems, zb0002)
			}
			for za0001 := range z.Items {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Items[za0001] = nil
				} else {
					if z.Items[za0001] == nil {
						z.Items[za0001] = new(ListItem)
					}
					bts, err = z.Items[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Items", za0001)
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *View) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.ContentType) + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Items {
		if z.Items[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Items[za0001].Msgsize()
		}
	}
	return
}
